package net.snowtiger.special.spliced

import net.snowtiger.methodmaker.GoodPn
import net.snowtiger.ringing._
import net.snowtiger.spliced.MethodReplacer.PruneVals
import net.snowtiger.spliced.composition.MusicCount
import net.snowtiger.spliced.score.MusicRun
import net.snowtiger.spliced.tables.Lead
import net.snowtiger.spliced.{MethodAssessor, MethodReplacer}

import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.io.Source

/**
 * Fills in methods for splices generated by {@link SpliceLHHLWeaver}
 *
 * @author mark
 */
object CyclicSpliceSearch
{
	val nbells = 10
	val bristol = NamedMethod("Bristol", 10, "x50x14.50x50.36.14x70.58.16x16.70x16x10", "10")						// g
	val horsleydown = NamedMethod("Horsleydown", 10, "x50x14.50x50.36.14x70.58.16x16.70x16x10", "12")				// b
	val triton = NamedMethod("Triton", 10, "30x30.14x12x10x12x50.14x14.70.16x18.90", "12")							// f
	val yorkshire = NamedMethod("Yorkshire", 10, "x30x14x50x16x1270x38x14x50x16x90", "12")							// b
	val woodstock = NamedMethod("Woodstock", 10, "x30x14x50x16x1270x38x14x50x16x90", "10")							// g
	val remus = NamedMethod("Remus", 10, "-3-4-2.5.6-34-5-6-67-6-7", "10")														// l
	val sgurr = NamedMethod("G Sgurr A'Chaorachain", 10, "x50x14.50x12.30x34x50.16x16.70x16x70 ", "10")		// k1
	val endOfExams = NamedMethod("End Of Exams", 10, "-30-14-12.50.16-34-50-16-1670-16-70", "12")		// f
	val snowtiger = NamedMethod("Snow Tiger", 10, "30-50.14-50-30.12-90.18-16-70.16-18.90", "12")		// a
	val exmoor = NamedMethod("Exmoor Gold", 10, "-50-14.50.12.50.36.12-1470.58.16-16.70-16-10", "10")	// g
	val frodo = NamedMethod("Frodo", 10, "-50-14.50.12-30-34-50.16-16.70-78-10", "10")								// j1
	val durin = NamedMethod("Durin", 10, "-30-10-12-36.14-14.50.16-14.50.14.56-50", "12")								// d1

	val blackPearl = NamedMethod("Black Pearl", 10, "-5-4.5-2.3.2-9.8.9-6.7-6-10", "10")    			// j1
	val bluePuma = NamedMethod("Blue Puma", 10, "5-34.1.56.7.2.36.7-4.58.9.4.56.1.78-6.90", "12")	// a
	val pooh = NamedMethod("Pooh", 10, "3-5.4-5-36-34.7.8-6-7.6-78.10", "12")												// c1
	val robin = NamedMethod("Robin", 10, "3-5.4-5-8-7.4.5.6-6.7-6-9", "12")                        	// f
	val smallsfriends = NamedMethod("Small's Friends", 10, "-5-4.5-2.3-3478-58-6-7.6-8.9", "10")		// k1
	val eeyore = NamedMethod("Eeyore", 10, "3-5.4-5-10-78.4.58-56-5.6-78.9", "12")									// f

	val oxcombeReplace = NamedMethod("Oxcombe Replacement", 10, "-34.50.14-50-36.14-78.10-16-70-18-30", "10")	// j1
	val belgraveReplace = NamedMethod("Belgrave Replacement", 10, "-30-14-50-16-14-50.16-14.70.38-18.50", "12")				// a
	val peroReplace5 = NamedMethod("Pero's Bridge Replacement", 10, "34-30.14-12-36-14.70.18-16-70.16.78-90", "10")		// h
	val thimblebyReplace = NamedMethod("Thimbleby Replacement", 10, "-30-10-12-36.14-14.50.16-14.50.14.56-50", "12")		// d1

	val unrungMethods = Set(blackPearl, bluePuma, pooh, robin, smallsfriends, eeyore, oxcombeReplace, belgraveReplace, peroReplace5, thimblebyReplace)

	val osterleyReplace = NamedMethod("Osterley Replacement", 10, "-34-14-12.50.16-14-1250-14-70-16.38.10", "10")			// m	+19
	val altSgurrReplace = NamedMethod("ALT Sgurr Replacement", 10, "-50-16-12-10.78-14.58.14-16.70-16-70", "12")		// D +48
	val altQuarndonReplace = NamedMethod("ALT Quarndon Replacement", 10, "-50.36.14.70-70.16.34-34.58.14-14.30-18-70", "12")	// C +43
	val coatReplace = NamedMethod("Coat Replacement", 10, "34-50.14-50-30.14-78.50-16-70.16.78-70", "10")						// l +6
	val horsefairReplace = NamedMethod("Horsefair Replacement", 10, "34-50.16-56-36.12-70.58.16-14.70-14-10", "10")	// g +28

	val poohReplace = NamedMethod("Pooh Replacement", 10, "30-50.16.70-70.36.14-34.18.36.14-70.14-78.50", "12")			// c1 +36
	val altSagaReplace = NamedMethod("ALT Saga Replacement", 10, "36.50-18.70-12.36.14-1470.38-56-50.36.18.36.10", "10")	// g +84
	val oxcombeReplace2 = NamedMethod("Oxcombe Replacement 2", 10, "-34-14-12.50.16-14-38.14.36-70.18-18.70", "10")	// j

	val osterleyReplace2 = NamedMethod("Osterley Replacement 2", 10, "-34-14-12-30.14-3470.58-36-1470.58.14-50", "10")	// j
	val horsefairReplace2 = NamedMethod("Horsefair Replacement 2", 10, "34-50.16-12-36.14-70.18-56-50.18.36.18.30", "10")	// g
	val altQuarndonReplace2 = NamedMethod("ALT Quarndon Replacement 2", 10, "-30-14-1270.58.16.70.12.70.58-16-50-18-90", "12")	// C

	val kingerbyReplace = NamedMethod("Kingerby Replacement", 10, "-34-14.70.56.70.36-78-58.14-14.50-58.16.90", "10")	// h +32
	val stNeotsReplace = NamedMethod("St Neots Replacement", 10, "36-34.16.50.12-36.70-14.50-14-70.58-14.90", "12")		// a +25
	val sgurrReplace = NamedMethod("Sgurr Replacement", 10, "-30-14-12-10.34-1470.58-56.14.50.14-58.90", "12")				// k +18
	val derwentEdgeReplace = NamedMethod("Derwent Edge Replacement", 10, "50-36.14.50.12.58.36.14-70.58-16-70.16-56.70", "12")	// c +50
	val coatReplace2 = NamedMethod("Coat Replacement 2", 10, "-50-14.50-12.30-34.70.58.16-16.70.16-56.90", "10")			// l +24
	val stNeotsReplace2 = NamedMethod("St Neots Replacement 2", 10, "50.36.50.14.56-50.16-14-50-56-70-18.36.50", "12")	// a +11
	val altHorsefairReplace = NamedMethod("ALT Horsefair Replacement", 10, "50-36.14-12.50.18.70-14.58.14.56-70-38.16.30", "10")	// g +2
	val kingerbyReplace2 = NamedMethod("Kingerby Replacement 2", 10, "-34-14-56-3670-70-58.14-14.70-58.16.90", "10")	// h +10

	val stNeots3 = NamedMethod("St Neots 3", 10, "-30-14-12-30.14-34.10-16-70.58-58.10", "12")		// a +14
	val kingerby3 = NamedMethod("Kingerby 3", 10, "34-36.14-12.70.38.70.14-58-56-70-18-90", "10")	// h +18
	val coat3 = NamedMethod("Coat 3", 10, "-30-14-12.50.16-12-58-56-30.18-14.90", "10")						// l + 24
	val bristol2 = NamedMethod("Bristol 2", 10, "36-36.10-50.12.36.14-14.50.36-56.70.18-78.30", "10")	// g +26
	val derwentEdge2 = NamedMethod("Derwent Edge 2", 10, "-30-10-56-36.12-14.50.36-16.70-16-70", "12")	// c +20
	val ingoldsby2 = NamedMethod("Ingoldsby 2", 10, "36.50-10.56.70.58.3670.14-70.58-16-70.16.78-70", "10")	// k +14
	val bristol3 = NamedMethod("Bristol 3", 10, "34-50.16-56-36-12.70.58.16-14.70-14-10", "10")	// g +28

	val stNeots4 = NamedMethod("St Neots 4", 10, "-30-10-56-36.14-1470.38-56-70.18-18.70", "12")		// a +53
	val paleRider2 = NamedMethod("Pale Rider 2", 10, "36-50.14-50-36.12-14.50.14.56-50.16-38.10", "12")		// e +32
	val bristol5 = NamedMethod("Bristol 5", 10, "34-30.16-56-36.14-70.58.16-14.70-14-10", "10")						// g +24
	val paleRider3 = NamedMethod("Pale Rider 3", 10, "36-50.14-1250-36.14-14.50-56-50.16-38.10", "12")		// e +6
	val farmersGlory2 = NamedMethod("Farmer's Glory 2", 10, "30-50.16.70-70.16-70-50-14-1470.56-78.50", "12")	// c +56

	val paleRider1 = NamedMethod("Pale Rider 1", 10, "-34-14.56-70.36.70-70.58.14-14.50.36-18.30", "12")	// e +36
	val stNeots5 = NamedMethod("St Neots 5", 10, "-30-10-12-36.14-1470.58.16-56.70-38-10", "12")					// a +54
	val bedford1 = NamedMethod("Bedford 1", 10, "-30-14-12-36.14.70.12.50-56-70-18-10", "10")							// m +18
	val bristol4 = NamedMethod("Bristol 4", 10, "34-50.14.70-70.36-70-10-56-50.16-78.10", "10")						// g +30
	val farmersGlory1 = NamedMethod("Farmer's Glory 1", 10, "30-50.18.50-1250.38-1470-50-56-1470.58.14-70", "12")	// c +34
	val pero6 = NamedMethod("Pero's Bridge 6", 10, "-50-14.50.12.50.16.34-14.58-16.34.10-58-50", "10")		// h +5

	val oxcombe3 = NamedMethod("Oxcombe 3", 10, "-34-14-56.70.38-70-18-16-10.58-1458.90", "10")						// j +15
	val bristol6 = NamedMethod("Bristol 6", 10, "34-50.16.70-1270.36-14-50.14-14.70.58-78.10", "10")			// g +35
	val hartington1 = NamedMethod("Hartington 1", 10, "-50-14.50-50.36.1478-78.50-16-70.16-78.10", "10")	// m +9
	val thimbleby2 = NamedMethod("Thimbleby 2", 10, "-50-16-1250-3670.14.70-50-14-1470.58-58.70", "12")		// d1 +6

	val goldfinger1 = NamedMethod("Goldfinger 1", 10, "30-50.16-56-30.14-14.58.14-16.70-78-10", "12")		// b +7
	val bristol7 = NamedMethod("Bristol 7", 10, "34-50.14-12-36-34.70.58.16-14.70-14-10", "10")					// g +41
	val hartington2 = NamedMethod("Hartington 2", 10, "34-50.14-50-30.14-70.58-16-70.16-78.10", "10")		// m +12
	val thimbleby3 = NamedMethod("Thimbleby 3", 10, "-50-16-50-1670-70-50-14-1470.58-78.50", "12")			// d1 +12
	val oxcombe4 = NamedMethod("Oxcombe 4", 10, "36-34.16.58-58.30.14-14.58-56-50-56.18.90", "10")			// j +19

	val bristol8 = NamedMethod("Bristol 8", 10, "36-34.16.50-12.36-14-50-12-70.16.38.16.30", "10")					// g +11
	val farmersGlory3 = NamedMethod("Farmer's Glory 3", 10, "30-50.14-12-36.14-70.58.16-14.70-14-10", "12")	// c +0
	val coat4 = NamedMethod("Coat 4", 10, "-30-14.50.12-10-12.70.58-16-70.16-56.90", "10")									// l + 12
	val belgrave2 = NamedMethod("Belgrave 2", 10, "-50-18-70-10-78-50-56-1470-36-10", "12")									// a + 26
	val blackPearl2 = NamedMethod("Black Pearl 2", 10, "-30-14-12-36-34.70.18.36.14-50-58-10", "10")				// j + 7
	val whitley2 = NamedMethod("Whitley 2", 10, "-34-14.50-78.36-70-18-56-50-18-10", "10")									// k + 18
	val adlergrove2 = NamedMethod("Aldergrove 2", 10, "-34-14.70-70.36.14-70.18-56-50.18-78.10", "10")			// m + 15
	val coat5 = NamedMethod("Coat 5", 10, "-30-14.50.12-10-12.70.58-16-70.16-78.90", "10")									// l + 0


	val extraMethods = Set(osterleyReplace, altSgurrReplace, altQuarndonReplace, coatReplace, horsefairReplace, poohReplace, altSagaReplace,
		oxcombeReplace2, osterleyReplace2, horsefairReplace2, altQuarndonReplace2, kingerbyReplace, stNeotsReplace, sgurrReplace, derwentEdgeReplace,
		coatReplace2, stNeotsReplace2, altHorsefairReplace, kingerbyReplace2, stNeots3, kingerby3, coat3, bristol2, derwentEdge2, ingoldsby2, bristol3,
		stNeots4, stNeots5, paleRider1, bedford1, bristol4, farmersGlory1, pero6, paleRider2, bristol5, paleRider3, farmersGlory2,
		oxcombe3, bristol6, hartington1, thimbleby2, goldfinger1, bristol7, hartington2, thimbleby3, oxcombe4,
		bristol8, farmersGlory3, coat4, belgrave2, blackPearl2, whitley2, adlergrove2, coat5)

	val methodAssessor = MethodAssessor(nbells)
	def filterFN(m: NamedMethod) = methodAssessor.isGoodRoyal(m)
	//def filterFN(m: MethodAnalysis) = methodAssessor.isPrettyGood(m)
	val goodSurprise = methodAssessor.parseMethods(Source.fromFile("SurpriseRoyal.txt")).filter(filterFN)
	val goodDelight = methodAssessor.parseMethods(Source.fromFile("DelightRoyal.txt")).filter(filterFN)
	val baseLibraryMethods = goodSurprise++goodDelight++unrungMethods++extraMethods
	val baseMethodPNSet = baseLibraryMethods.map(_.lead).toSet
	def altMethod(m: NamedMethod): Option[NamedMethod] = {
		val lhPN = if (m.leadheadPN==PN("12")) PN("10") else PN("12")
		val newMethod = NamedMethod("ALT "+m.name, nbells, m.firstHalfPN, lhPN)
		val long10ths = lhPN==PN("10") && m.lead(0).isPlace(10)
		if (!long10ths && /*newMethod.courseLength==m.courseLength &&*/ !baseMethodPNSet(newMethod.lead))
			Some(newMethod)
		else
			None
	}
	val libraryMethods = baseLibraryMethods ++ baseLibraryMethods.flatMap(altMethod)
	val lhgConversion = Map("a"->"a", "b"->"b", "c"->"C", "c1"->"c", "d1"->"d", "d"->"D", "e"->"e", "f"->"f",
													"g"->"g", "h"->"h", "j"->"J", "j1"->"j", "k1"->"k", "k"->"K", "l"->"l", "m"->"m", "z"->"z", "-"->"-")
	def byLHG(library: Iterable[NamedMethod]) = library.groupBy((m)=> lhgConversion(m.lhGroup))
	val libraryMethodsAll = byLHG(libraryMethods)
	val libraryMethods10 = byLHG(libraryMethods.filter(_.halfleadPN!=PN("90")))
	val libraryMethods90 = byLHG(libraryMethods.filter(_.halfleadPN!=PN("10")))
	val libraryMethodsNonPBHL = byLHG(libraryMethods.filter(_.firstLead.filter(_.bellAt(10)==1).forall(!_.isPlainBob)))

	val cyclicPerm = Perm("1902345678")

	val MinScore = 500

	// Node heads for the two composition variations: 2nd or 0th bobbed through. The last two nodes are the transitions.
	val nodeHeads = Map("bob2"-> "1234567890 1082694735 1083624957 1642385079 1643587092",
		"bob0" -> "1234567890 1350729486 1039527486 1790856342 1579836042").mapValues(_.split(' ').toList.map(Row(_))).map(identity).toMap

	def main(args: Array[String]): Unit =
	{
		//val replaceMethodInExistingComp: Option[String] = None

		//val compStr = "bob2 9 4 mchh / mc / ddh /  (hd mcc 4h 3d 3m 4c), (hd cmc 4h 3d 3m 4c)"

		// Best = 514 jfhh / hd / jf / jjf / ddh h=Pero's Bridge Replacement j=Uckerby d=Thimbleby f=Harrison
		//val compStr = "bob2 9 4 jfhh / jf / ddh /  (hd jjf 4h 4j 3d 3f)"

		//val compStr = "bob2 9 4 jjfa / aaa / mj /  (ff fmm 3j 3m 4a 4f), (ff mfm 3j 3m 4a 4f), (ff mmm 3j 4m 4a 3f), (mf ffm 3j 3m 4a 4f), (mf fmm 3j 4m 4a 3f), (mf mfm 3j 4m 4a 3f)"


		// BRISTOL (g)
		//val myMethod = bristol
		//val myMethod = woodstock
		//val myMethod = exmoor

		// Bristol Best = 554 jgl / dg / dddj / jjl / lg g=Bristol j=Uckerby d=ALT Fussell l=Ringinglow
		// Woodstock Best = 503	jgl / ljj / dddj / dg / lg g=Woodstock j=Uckerby d=Thimbleby l=Phobia
		// Exmoor Gold Best = 573 jgl / dg / dddj / jjl / lg g=Exmoor Gold j=Fussell d=Thimbleby l=Phobia
		// Best = 610 jgl / dg / dddj / jjl / lg j=Fussell d=Thimbleby Replacement g=Exmoor Gold l=Phobia
		//val compStr = "bob0 jgl dddj lg dg jjl g=Exmoor Gold j=Fussell d=Thimbleby Replacement l=Phobia"
		//val compStr = "bob0 jgl dddj lg dg jjl g=Bristol j=Fussell d=Clowne l=Ringinglow"
		//val compStr = "9 4 jgl / dddj / lg /  (dg jjl 4j 4d 3g 3l), (dg jlj 4j 4d 3g 3l), (dg ljj 4j 4d 3g 3l)"

		// 3-SPLICED
		//val compStr = "bob0 9 3 jjj / aa / aahj /  (jh hhh 5h 5j 4a), (hj hhh 5h 5j 4a)"
		//val compStr = "bob0 jjj aa aahj jh hhh h=Pero's Bridge Replacement j=Oxcombe Replacement a=Belgrave Replacement"

		// 7-SPLICED
		val pinMethod = false
		val myMethod = bristol
		//val compStr = "bob0 9 7 mj / aa / bhmel /  (jh ble ), (jh leb ), (jh lbe ), (bj lhe ), (bj hle ), (hj elb ), (hj ble ), (hj leb ), (hj lbe )" // NO g!!

		// Plan A
		//val compStr = "bob0 9 7 c / DchmCD / lg  (gCh ml ), (gCh lm ), (ml Chg ), (ml hCg ), (lm Chg ), (lm hCg )"
		// 725/364/150/2
		//val replaceStr = "bob0 9 7 c / ml / DchmCD / hCg / lg m=Osterley Replacement 2 g=Horsefair Replacement 2 l=Phobia C=ALT Quarndon Replacement 2 c=Hangingwater h=Pero's Bridge Replacement D=ALT Sgurr Replacement"

		// Plan B
		//val compStr = "bob0 9 7 jgf / Dcck / lg  (fl jDk ), (fl kDj ), (fl Djk ), (fl Dkj ), (jDk fl ), (kDj fl ), (Djk fl ), (Dkj fl )"
		// 713/381/181/2
		//val replaceStr = "bob0 9 7 jgf / fl / Dcck / Djk / lg j=Oxcombe Replacement 2 f=Harrison g=ALT Saga Replacement l=Phobia c=Pooh Replacement k=Ingoldsby D=ALT Ingoldsby"

		// Plan C
		//val compStr = "bob2 9 7 mCD / lgc / Dch  (ml gCh ), (lm gCh ), (Chg ml ), (hCg ml ), (Chg lm ), (hCg lm )"
		// 700/355/157/2
		//val replaceStr = "bob2 9 7 mCD / hCg / lgc / ml / Dch m=Osterley Replacement g=Horsefair Replacement l=Coat Replacement C=ALT Quarndon Replacement c=Raisthorpe h=Pero's Bridge Replacement D=ALT Sgurr Replacement"

		// Plan 1
		//val compStr = "bob0 9 7 kmm / adfk / lg /  (fl gad ), (fl gda ), (fl dga ), (dg fla ), (dg alf ), (dg lfa ), (dg laf )"

		// Plan 2
		val replaceMethodInExistingComp: Option[String] = None //Some("j")
		// New best = 679 jgf / ak / adfk / jld / lg j=Oxcombe Replacement f=Melrose a=St Neots Replacement 2 g=Horsefair Replacement 2 l=Phobia k=ALT ALT Sgurr Replacement d=Thimbleby 2
		val compStr = "bob0 9 7 jgf / adfk / lg /  (ak jld ), (ak ljd )"
		val replaceStr = "bob2 9 7 jgf / jld / adfk / ak / lg j=Oxcombe Replacement f=ALT Coat a=January g=Bristol l=Coat k=Ingoldsby d=Thimbleby Replacement"

		// Plan 3
		//val compStr = "bob0 9 7 kmm / acaj / lg (gk lcj ), (gk cjl ), (gk jcl ), (kg jcl ), (kg lcj ), (kg cjl ), (kg clj )"
		// 746/297/127/2
		//val replaceStr = "bob0 9 7 kmm / jcl / acaj / gk / lg j=Black Pearl 2 a=Belgrave 2 m=Aldergrove 2 g=Bristol 8 l=Coat 5 c=Farmer's Glory 3 k=Whitley 2"

		// Plan 4
		//val compStr = "bob0 9 7 mj / adkgbk / m /  (bj gad ), (bj gda ), (bd jag ), (bd ajg ), (bd agj ), (bd gaj ), (db jag ), (db ajg ), (db agj ), (db gaj ), (dg jab ), (dg jba ), (dg ajb ), (dg bja )"
		// 716/296/117/2
		//val replaceStr = "bob0 9 7 mj / dg / adkgbk / ajb / m j=Oxcombe 4 a=January m=Hartington 2 b=Goldfinger 1 g=Bristol 7 k=Sgurr A'Chaorachain d=Thimbleby 3"
		// 690/274/113/2
		//val replaceStr = "bob0 9 7 mj / dg / adkgbk / ajb / m j=Oxcombe 3 a=January m=Hartington 1 b=Goldfinger g=Bristol 6 k=Sgurr A'Chaorachain d=Thimbleby 2"

		// Plan 6
		//val compStr = "bob0 9 7 ecaggf / mh / m /  (ch eaf ), (ch fea ), (ch fae ), (ch aef ), (ch afe )"
		// 696/313/112/2
		//val replaceStr = "bob0 9 7 ecaggf / fea / mh / ch / m e=Pale Rider 3 f=ALT Coat a=St Neots 4 m=Bedford 1 g=Bristol 5 c=Farmer's Glory 2 h=Pero's Bridge 6"
		// 679/296/122/2
		//val replaceStr = "bob0 9 7 ecaggf / fea / mh / ch / m e=Pale Rider 1 f=ALT Coat a=St Neots 5 m=Bedford 1 g=Bristol 4 c=Farmer's Glory 1 h=Pero's Bridge 6"

		// Plan 7
		//val compStr = "bob0 9 7 bhgl / ack / lg  (ahc kb )"
		//val replaceStr = "bob0 9 7 bhgl / kb / ack / ahc / lg a=St Neots b=Goldfinger g=Bristol l=Coat c=Derwent Edge h=Kingerby k=Ingoldsby"
		// 800/338/148/2
		//val replaceStr = "bob0 9 7 bhgl / ahc / ack / kb / lg a=St Neots Replacement 2 b=ALT Horsefair Replacement g=Horsefair l=Coat Replacement 2 c=Derwent Edge Replacement h=Kingerby Replacement 2 k=Sgurr Replacement"
		// 746/304/172/2
		//val replaceStr = "bob0 9 7 bhgl / kb / ack / ahc / lg a=St Neots 3 b=Goldfinger g=Bristol 3 l=Coat 3 c=Derwent Edge 2 h=Kingerby 3 k=Ingoldsby 2"

		//val compStr = "bob0 9 7 echgl / dk / lg  (ekc hd )"

		if (replaceMethodInExistingComp.isDefined)
		{
			replaceMethod(replaceMethodInExistingComp.get, replaceStr)
		}
		else if (compStr.contains('/'))
		{
			val comps = parseCompVariations(compStr)
			for (comp <- comps)
				populateMethods(comp)
			println((if (pinMethod) myMethod.name+" " else "")+"Best = "+bestMusic+" "+bestComp)
		}
		else
		{
			val comp = parseComp(compStr)
			populateMethods(comp)
		}

		def populateMethods(comp: CompTemplate): Unit =
		{
			println(comp.desc)
			if (pinMethod)
			{
				val myMethodRows = genRows(myMethod, comp).get
				val myMethodLHG = myMethod.lhGroup.substring(0, 1)
				search(Map(myMethodLHG -> myMethod), comp, myMethodRows)
			}
			else
				search(Map(), comp, Set())
			println()
		}
	}

	//def rowFn(nRows: Int) = if (nRows<6) 0 else if (nRows<8) nRows/2 else if (nRows<12) nRows-1 else nRows*2

	//def rowFn(nRows: Int) = if (nRows<8) 0 else if (nRows<12) nRows/2 else if (nRows<20) nRows-2 else nRows
	//def rowFn(nRows: Int) = if (nRows<8) 0 else if (nRows<12) nRows/2 else if (nRows<20) nRows-2 else nRows+1
	//def rowFn(nRows: Int) = if (nRows<4) 0 else if (nRows<8) nRows/2 else if (nRows<12) nRows-2 else nRows+1
	def rowFn(nRows: Int) = if (nRows<8) nRows else nRows+1
	//def rowFn(nRows: Int) = if (nRows<6) nRows-1 else nRows+2

	//def rowFn(nRows: Int) = if (nRows<6) nRows-1 else if (nRows<10) nRows+2 else (nRows*1.5).toInt

	val pbHLGroups = Set("a", "f", "l", "g")

	val music = new MusicRun(4)
	val backRoundsMusic = new MusicRun(10)

	var bestMusic = 0
	var bestComp = ""

	def replaceMethod(lhgToReplace: String, compStr: String): Unit =
	{
		val (comp,methods) = parseCompAndMethods(compStr)
		val allPns = GoodPn(nbells).oneConsec.toSet
		val openingPns = List(PN("34"), PN("36"), PN("50"), PN("30"), PN("-"))
		val tdPns = openingPns::openingPns::openingPns::(MethodReplacer.trebleDodgingPns(nbells, allPns).tail.tail.tail)

		val musicDefs: Array[Music] = Array(new MusicRun(4), new MusicRun(5), new MusicRun(6), backRoundsMusic)
		val musicCount = new MusicCount(musicDefs)
		val leadsOfComp = generateLeadsOfComp(methods, comp.leadsPerMethod)
		val methodToReplace = methods(lhgToReplace)
		val leadsToReplace = leadsOfComp(methodToReplace)
		val rowsPerMethod = leadsOfComp.mapValues(_.flatMap(_.getRows)).toMap
		val musicPerMethod = rowsPerMethod.mapValues(musicCount.count).toMap
		val allMusic = MusicCount.sumAll(musicPerMethod.values)
		println("Current comp music = "+allMusic)
		val musicToReplace = musicPerMethod(methodToReplace)
		val currentMusic = musicToReplace(0)+musicToReplace(2)
		val currentMusicPerRow = currentMusic.toFloat/(nbells*2)

		def pruner(level: Int, currentRows: List[Row], pv: PruneVals): Option[PruneVals] =
		{
			def rowToPositions(row: Row): List[Set[Char]] = row.bells.grouped(2).map(_.toSet).toList
			def notStatic(positions: List[Option[Set[Char]]], prevRows: List[Row], nStatic: Int): Boolean =
			{
				if (positions.forall(_.isEmpty))
					true
				else if (nStatic>10)
					false
				else if (prevRows.isEmpty)
					true
				else
				{
					val rowPositions = rowToPositions(prevRows.head)
					val nextPositions = rowPositions.zip(positions).map((p)=> if (p._2.isDefined && p._2.get==p._1) Some(p._1) else None)
					notStatic(nextPositions, prevRows.tail, nStatic+1)
				}
			}
			val nRows = pv.firstHLRows.size
			val effectiveRows = rowFn(nRows)
			val expectedMusic = effectiveRows*currentMusicPerRow
			val newMusic = pv.nextMusic(currentRows)
			val musicScore = newMusic(0)+newMusic(2)
			//val musicGood = musicScore>=expectedMusic && (nRows<20 || newMusic(3)>=musicToReplace(3) )
			val musicGood = musicScore>=expectedMusic && (nRows<20 || (0 until 4).forall((i)=> newMusic(i)>=musicToReplace(i)) )
			if (musicGood && notStatic(rowToPositions(currentRows.head).map(Some(_)), pv.firstHLRows, 0))
				Some(pv.next(currentRows, newMusic))
			else
				None
		}

		val otherRows = leadsOfComp.filterKeys(_!=methodToReplace).values.flatten.map(_.getRows).flatten.toSet
		println("Replacing "+methodToReplace.name+" with music = "+musicToReplace)
		MethodReplacer.replaceMethods("", List(methodToReplace), tdPns, musicCount, otherRows, leadsToReplace, 1, pruner)
	}

	def search(methods: Map[String,NamedMethod], comp: CompTemplate, allRows: Set[Row]): Unit =
	{
		if (methods.size==comp.leadsPerMethod.size)
		{
			val allRowsList = allRows.toList
			val backrounds = 2==backRoundsMusic.countMusic(allRowsList)
			val runs = music.countMusic(allRowsList)
			if (backrounds && runs>=MinScore)
			{
				val compStr = comp.desc+" "+methods.map((p) => p._1 + "=" + p._2.description).mkString(" ")
				println(runs + "\t" + compStr)
				if (runs > bestMusic)
				{
					bestMusic = runs
					bestComp = compStr
				}
			}
		}
		else
		{
			val lhg = comp.leadsPerMethod.keys.find(!methods.contains(_)).get
			//print(" "+lhg)
			//val library = if (lhg=="g") libraryMethods10 else if (pbHLGroups(lhg)) libraryMethods90 else libraryMethodsNonPBHL
			val library = libraryMethodsAll
			for (method <- library.getOrElse(lhg, Nil))
			{
				//print(" "+method)
				val rowsOpt = genRows(method, comp)
				if (rowsOpt.isDefined)
				{
					val rows = rowsOpt.get
					val newRows = allRows ++ rows
					if (newRows.size == allRows.size + rows.size)
						search(methods+(lhg->method), comp, newRows)
				}
			}
		}
	}

	def genRows(method: NamedMethod, comp: CompTemplate): Option[Set[Row]] =
	{
		val rows = mutable.Set[Row]()
		var rowsExpected = 0
		val compLeads = comp.leadsPerMethod(lhgConversion(method.lhGroup))
		for (lh <- compLeads)
		{
			val cyclicRows = genCyclicCourse(method, lh)
			rowsExpected+= cyclicRows.size
			rows++= cyclicRows
		}
		if (rows.size==rowsExpected)
			Some(rows.toSet)
		else
			None
	}

	val pbLeads = new Method(10, "-1-1-1-1-1", "12").leadHeads.map(_.toPerm)
	val lhgPerms: Map[String,Perm] = Map("a"->0, "b"->1, "C"->2, "c"->3, "d"->4, "D"->5, "e"->6, "f"->7,
		"g"->0, "h"->1, "J"->2, "j"->3, "k"->4, "K"->5, "l"->6, "m"->7).mapValues(pbLeads).map(identity).toMap

	case class CompTemplate(desc: String, leadsPerMethod: Map[String,List[Row]])
	{
		def this(desc: String, leads: Seq[(String,Row)]) = this(desc, leads.toList.groupBy(_._1).mapValues(_.map(_._2)).map(identity).toMap)
	}

	/** Returns map LHG -> leadheads for that method */
	def parseComp(compStr: String): CompTemplate =
	{
		var comp = ListBuffer[(String,Row)]()
		val split = compStr.split(" ")
		val courseHeads = nodeHeads(split(0))
		if (courseHeads.size==5)
		{
			expandLeadsOfSplice(courseHeads(0), split(3), comp)
			expandLeadsOfSplice(courseHeads(1), split(7), comp)
			expandLeadsOfSplice(courseHeads(2), split(11), comp)
			expandLeadsOfSplice(courseHeads(3), split(5), comp)
			expandLeadsOfSplice(courseHeads(4), split(9), comp)
		}
		else
		{
			for (i <- 0 until courseHeads.size)
				expandLeadsOfSplice(courseHeads(i), split(i*2+3), comp)
		}
		new CompTemplate(compStr, comp.toSeq)
	}

	def parseCompAndMethods(compStr: String): (CompTemplate, Map[String,NamedMethod]) =
	{
		val i = compStr.indexOf('=')-1
		val comp = parseComp(compStr.substring(0, i))
		val methods = parseMethods(compStr.substring(i))
		(comp, methods)
	}
	
	def parseCompVariations(compStr: String): List[CompTemplate] =
	{
		val results = ListBuffer[CompTemplate]()
		val i = compStr.indexOf('(')
		val fixedPart = compStr.substring(0,i).split(' ')
		val variations = compStr.substring(i+1).split('(')
		val fixedComp = ListBuffer[(String,Row)]()
		val courseHeads = nodeHeads(fixedPart(0))
		expandLeadsOfSplice(courseHeads(0), fixedPart(3), fixedComp)
		expandLeadsOfSplice(courseHeads(1), fixedPart(5), fixedComp)
		expandLeadsOfSplice(courseHeads(2), fixedPart(7), fixedComp)
		for (variation <- variations)
		{
			val splices = variation.split(' ')
			results+= createTemplateComp(courseHeads, splices(0), splices(1), fixedPart, fixedComp)
			//results+= createTemplateComp(courseHeads, splices(1), splices(0), fixedPart, fixedComp)
		}
		results.toList
	}

	def createTemplateComp(courseHeads: List[Row], splice1: String, splice2: String, fixedPart: Array[String], fixedComp: ListBuffer[(String, Row)]): CompTemplate =
	{
		val leads = ListBuffer[(String,Row)]()
		expandLeadsOfSplice(courseHeads(3), splice1, leads)
		expandLeadsOfSplice(courseHeads(4), splice2, leads)
		val desc = fixedPart(3) + " / " + splice1 + " / " + fixedPart(5) + " / " + splice2 + " / " + fixedPart(7)
		new CompTemplate(desc, leads.toList ++ fixedComp)
	}

	def expandLeadsOfSplice(ch: Row, splice: String, leads: ListBuffer[(String,Row)]): Unit =
	{
		var lh = ch
		for (lhgChar <- splice)
		{
			val lhg = lhgChar.toString
			leads+= Tuple2(lhg, lh)
			lh = lh.apply(lhgPerms(lhg))
		}
	}



	/**
	 * Turns e.g. g=Bristol b=Goldfinger k=Sgurr A'Chaorachain m=Bedford in a map a->Bristol, b->Goldfinger etc.
	 */
	def parseMethods(methodStr: String): Map[String,NamedMethod] =
	{
		val buf = ListBuffer[(String,NamedMethod)]()
		var str = methodStr.trim+" END"
		var i = str.indexOf('=')
		var lhg = str.substring(0,i)
		while (i<str.length)
		{
			var i2 = str.indexOf('=', i+1)
			if (i2<0)
				i2 = str.length
			val methodPlusNextLHG = str.substring(i+1, i2)
			val j = methodPlusNextLHG.lastIndexOf(' ')
			val methodName = methodPlusNextLHG.substring(0, j)
			buf+= lhg -> libraryMethods.find(_.name==methodName).get
			lhg = methodPlusNextLHG.substring(j+1)
			i = i2
		}
		buf.toList.toMap
	}

	def genCyclicLeadHeads(m: Method, ch: Row): List[Row] =
	{
		val buf = ListBuffer[Row]()
		var lh = ch
		buf+= lh
		for (i <- 1 until nbells-1)
		{
			lh = lh.permuteBy(cyclicPerm)
			buf+= lh
		}
		buf.toList
	}

	def genCyclicCourse(m: Method, ch: Row): List[Row] =
	{
		val buf = ListBuffer[Row]()
		for (lh <- genCyclicLeadHeads(m, ch))
			m.generateLead(lh, buf)
		buf.toList
	}

	def generateLeadsOfComp(methods: Map[String,NamedMethod], comp: Map[String,List[Row]]): Map[NamedMethod, List[Lead]] =
	{
		def genLeadsForMethod(lhg: String): (NamedMethod, List[Lead]) =
		{
			val method = methods(lhg)
			val lhs = comp(lhg)
			val leads = lhs.flatMap(genCyclicLeadHeads(method,_)).map(Lead(_, method))
			(method, leads)
		}
		comp.keys.map(genLeadsForMethod).toMap
	}

}